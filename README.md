## Виртуальная машина Java (Java Virtual Machine)
- это механизм, предоставляющий среду выполнения для управления
Java-кодом или приложениями.
Виртуальная машина является независимой оболочкой исполнения кода, благодаря которой возможен её запуск на любой ОС,
без влияния ОС на выполняемую программу.

При запуске JVM, используются три загрузчика классов:

* Bootstrap class loader (Загрузчик класса Bootstrap)
* Extensions class loader (Загрузчик класса расширений)
* System class loader (Системный загрузчик классов)

**Загрузчик класса Bootstrap** загружает основные библиотеки Java, расположенные в папке `<JAVA_HOME>/jre/lib`.
Этот загрузчик является частью ядра JVM, написан на нативном коде.

**Загрузчик класса расширений** загружает код в каталоги расширений
(`<JAVA_HOME>/jre/lib/ext`, или любой другой каталог, указанный системным свойством `java.ext.dirs`).

**Системный загрузчик** загружает код, найденный в `java.class.path`, который сопоставляется с переменной
среды `CLASSPATH`.
Это реализуется классом `sun.misc.Launcher$AppClassLoader`.

**Java Virtual Machine Stacks**

Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком.  Стек в JVM хранит frames.
Cтеки в JVM могут иметь фиксированный размер или динамически расширяться и сжиматься в соответствии с требованиями вычислений.

**Heap**

JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java.
Куча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и массивов классов.
Куча создается при запуске виртуальной машины. Хранилище для объектов восстанавливается автоматической системой
управления данными (известной как сборщик мусора); объекты никогда не освобождаются явно.
JVM не предполагает какого-либо конкретного типа системы автоматического управления хранением данных,
и метод управления может быть выбран в соответствии с системными требованиями разработчика.
Куча может иметь фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена,
если большая куча становится ненужной. Память для кучи не должна быть смежной.

**Frames**

Frame используется для хранения данных и частичных результатов, а также для выполнения динамического связывания, возврата значений для методов и отправки исключений.
Новый frame создается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода,
является ли это завершение нормальным или резким (он генерирует неперехваченное исключение). Frames выделяются из стека потока, создающего frame.
Каждый frame имеет свой собственный массив локальных переменных, свой собственный стек операндов и ссылку на пул констант во время выполнения класса текущего метода.
Размеры массива локальных переменных и стека операндов определяются во время компиляции и предоставляются вместе с кодом для метода, связанного с фреймом.
Таким образом, размер структуры данных, frame-а зависит только от реализации виртуальной машины Java, и память для этих структур может быть выделена одновременно при вызове метода.

Только один frame активен в любой точке данного потока управления - метода выполнения, и это frame называется текущим, а его метод известен как текущий метод.
Класс, в котором определен текущий метод, является текущим классом. Операции над локальными переменными и стеком операндов обычно выполняются со ссылкой на текущий frame.

public class JvmComprehension {

В stack формируется frame main

    public static void main(String[] args) {
        int i = 1;                      // 1 Во frame main создается переменная  i, значение которой = 1
        Object o = new Object();        // 2 Переменная о создается в stack фрейма main и хранит в себе ссылку на объект, new Object создается для хранения в heap.
        Integer ii = 2;                 // 3 Integer является ссылочной переменной ii, помещается в stack main и хранит в себе ссылку на значение объекта Integer, само значение объекта создается для хранения в heap.
        printAll(o, i, ii);             // 4 В stack формируется frame printAll
        System.out.println("finished"); // 7 В stack формируется frame println, в котором создается ссылка на объект String "finished". Объект String создаётся для хранения в heap.
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5  В stack во frame printAll для хранения создается  переменная uselessVar, которая хранит в себе ссылку на объект Integer. Объект со значением 700 хранится в heap.
        System.out.println(o.toString() + i + ii);  // 6 В stack фомируется frame println и toString. В frame println передаются переменные i со значением 1, ii, o, последние из которых хранят ссылки на объекты Object o, Integer ii.
    }

}